import axios, { AxiosInstance, AxiosResponse } from 'axios';\nimport { describe, it, expect, beforeAll } from '@jest/globals';\n\ndescribe('GET /api/v1/runs', () => {\n  let axiosInstance: AxiosInstance;\n  const baseURL = process.env.API_BASE_URL || 'http://localhost:3000';\n  const validAuthToken = process.env.API_AUTH_TOKEN || 'valid-auth-token';\n\n  beforeAll(() => {\n    axiosInstance = axios.create({\n      baseURL,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n  });\n\n  it('should return 200 OK with no filters (happy path)', async () => {\n    const response: AxiosResponse = await axiosInstance.get('/api/v1/runs', {\n      headers: { Authorization: `Bearer ${validAuthToken}` },\n      params: {},\n    });\n\n    expect(response.status).toBe(200);\n    expect(response.headers['content-type']).toContain('application/json');\n\n    // Basic schema check (assuming response body matches ListRunsResult)\n    // Here, we assume the response has a 'runs' array and possibly 'pagination' info.\n    expect(response.data).toHaveProperty('runs');\n    expect(Array.isArray(response.data.runs)).toBe(true);\n  });\n\n  it('should return 200 OK with valid filters', async () => {\n    // Example of a valid filter (status, created at, etc.)\n    // Adjust the query parameters according to the actual filters allowed by your API.\n    const response: AxiosResponse = await axiosInstance.get('/api/v1/runs', {\n      headers: { Authorization: `Bearer ${validAuthToken}` },\n      params: {\n        status: 'completed',\n        // We can add more valid filters as needed\n      },\n    });\n\n    expect(response.status).toBe(200);\n    expect(response.headers['content-type']).toContain('application/json');\n    expect(response.data).toHaveProperty('runs');\n    expect(Array.isArray(response.data.runs)).toBe(true);\n  });\n\n  it('should return 400 or 422 for invalid parameter data type', async () => {\n    // E.g., passing a numeric parameter where a string is expected\n    // or a negative page size, etc.\n    try {\n      await axiosInstance.get('/api/v1/runs', {\n        headers: { Authorization: `Bearer ${validAuthToken}` },\n        params: { status: 123 }, // Invalid: expecting a string filter, but sending a number\n      });\n      // If the request does not throw, fail the test\n      fail('Expected request to fail with 400 or 422, but it succeeded.');\n    } catch (error: any) {\n      const status = error.response?.status;\n      // Check if status is 400 or 422 as mentioned in the instructions\n      expect([400, 422]).toContain(status);\n      expect(error.response?.headers['content-type']).toContain('application/json');\n    }\n  });\n\n  it('should return 401 or 403 for unauthorized request', async () => {\n    const invalidAuthToken = 'invalid-auth-token';\n    try {\n      await axiosInstance.get('/api/v1/runs', {\n        headers: { Authorization: `Bearer ${invalidAuthToken}` },\n      });\n      fail('Expected request to fail with 401 or 403, but it succeeded.');\n    } catch (error: any) {\n      const status = error.response?.status;\n      // According to the specs, it can be 401 or 403 if auth is invalid\n      expect([401, 403]).toContain(status);\n    }\n  });\n\n  it('should return 200 OK with an empty array if no runs are found', async () => {\n    // Passing filters that are guaranteed to yield zero results (example)\n    const response: AxiosResponse = await axiosInstance.get('/api/v1/runs', {\n      headers: { Authorization: `Bearer ${validAuthToken}` },\n      params: { status: 'this-status-does-not-exist' },\n    });\n\n    expect(response.status).toBe(200);\n    expect(response.headers['content-type']).toContain('application/json');\n    expect(response.data).toHaveProperty('runs');\n    expect(Array.isArray(response.data.runs)).toBe(true);\n    expect(response.data.runs.length).toBe(0);\n  });\n\n  it('should handle large pagination values', async () => {\n    // Example of testing a large limit or page, if supported by the API\n    // The #/components/parameters/cursorPagination might have a limit or page.\n    const largePage = Number.MAX_SAFE_INTEGER;\n    try {\n      const response: AxiosResponse = await axiosInstance.get('/api/v1/runs', {\n        headers: { Authorization: `Bearer ${validAuthToken}` },\n        params: { page: largePage },\n      });\n\n      // Some APIs might return 400 for out-of-range pages.\n      expect([200, 400, 422]).toContain(response.status);\n    } catch (error: any) {\n      // If an error is thrown, verify it is in the acceptable set (400 or 422).\n      const status = error.response?.status;\n      expect([400, 422]).toContain(status);\n    }\n  });\n\n  it('should validate the response headers (e.g., Content-Type)', async () => {\n    const response: AxiosResponse = await axiosInstance.get('/api/v1/runs', {\n      headers: { Authorization: `Bearer ${validAuthToken}` },\n    });\n    expect(response.status).toBe(200);\n    expect(response.headers['content-type']).toContain('application/json');\n\n    // Check additional headers if needed (e.g., Cache-Control, X-RateLimit, etc.)\n    // For example:\n    // expect(response.headers['cache-control']).toBeDefined();\n    // expect(response.headers['x-ratelimit-limit']).toBeDefined();\n  });\n});\n